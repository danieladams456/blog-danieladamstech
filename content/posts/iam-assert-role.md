---
title: "IAM Assert Role"
date: 2023-08-31T20:00:00-04:00
tags: ["architecture"]
---

Back at the start of 2021, I delved into a small curiosity project around how to assert ownership of an AWS role to a non-AWS entity. I implemented an API Gateway Sigv4 signer in a [Spring RestTemplate Interceptor](https://www.baeldung.com/spring-rest-template-interceptor). Later we integrated that design in a production app. That security integration has had zero issues since. As a thought experiment, I wanted to see if it was possible to use an IAM root of trust when calling other endpoints besides API Gateway. AWS Sigv4 authentication is a symmetric scheme, but to keep things simple with fewer security resources on the verification side, I knew I needed to use asymmetric verification.

This idea was inspired by CyberArk DAP [IAM Authenticator integration](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/Latest/en/Content/Operations/Services/AWS_IAM_Authenticator.htm) and [Hashicorp Vault IAM authenticator.](https://developer.hashicorp.com/vault/docs/auth/aws#iam-auth-method) Vault has a lot of cool technology in it! For another side project, I tried combining the [Shamir Secret Sharing](https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing) [package from Vault](https://github.com/hashicorp/vault/blob/main/shamir/shamir.go) with the [Format-Preserving Encryption](https://en.wikipedia.org/wiki/Format-preserving_encryption) [package from CapitalOne](https://github.com/capitalone/fpe) into my project [`shamirfpe`](https://github.com/danieladams456/shamirfpe/blob/master/shamirfpe.go).

Back to the topic at hand. The client wanting to assert ownership of an IAM role will pre-sign an STS [`GetCallerIdentity`](https://docs.aws.amazon.com/STS/latest/APIReference/API_GetCallerIdentity.html) request, which can then be executed by a trusted entity. Handing over this signature will not compromise the security of the IAM role secret keys. The trusted entity will get a response directly from AWS STS, which can be trusted. We then know the caller has that specific role session. Even administrators will not be able to generate application tokens if they are not trusted in the assume role policy. This maintains the same security posture as IAM-based access to AWS resources.

The presign and execute process could be done on every app request, but making a network call every time is slow and susceptible to throttling. We instead sign that assertion with [KMS asymmetric keys](https://aws.amazon.com/blogs/security/digital-signing-asymmetric-keys-aws-kms/). The `RSASSA_PKCS1_V1_5_SHA_256` algorithm supported by KMS is the same one used for `RS256` signed JWTs. Constructing the appropriate JWT header and body allows us to issue industry-standard tokens that can be verified by client libraries across many languages. In the standard JWT verification process, the verifier can have multiple public key IDs to support rotation of a specific key upon compromise. The backup signing key[s] can have deny policies in KMS during normal operation. If a key is compromised, it can be scheduled for deletion thereby disabling the key. The next key can be enabled for usage without applications having to always check the public key endpoint.

Below is a sequence diagram representing the three parties (client, assertion validator, and target resource) and two AWS services (STS and KMS.)

![AWS Assert Role Sequence Diagram](https://images.danieladamstech.com/2023-aws-assert-role.png)

My previous Sigv4 signer integration was in Java using the AWS SDK [AWS4Signer](https://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/com/amazonaws/auth/AWS4Signer.html), so I wanted to use some other languages for this exercise.

- Request formulation and presigning
  - [JavaScript via AWS SDK middleware](https://github.com/danieladams456/aws-assert-role/blob/main/presign-get-caller-identity/presign-via-middleware.js). This is a more roundabout hack method, but the SDK manages pulling credentials from the metadata endpoint and maintaining a fresh session token component
  - [JavaScript via AWS SDK SignatureV4](https://github.com/danieladams456/aws-assert-role/blob/main/presign-get-caller-identity/presign-via-sigv4.js) module. The code is very straightforward, but doesn't pull the credentials for you.
  - The cleanest way is using the external dependency from Michael Hart [`aws4`](https://github.com/mhart/aws4)
- [Posting to STS, signing with KMS, and constructing JWT](https://github.com/danieladams456/aws-assert-role/blob/main/verify-get-caller-identity/verifier.py) - Python
- [JWT verification](https://github.com/danieladams456/aws-assert-role/blob/main/local-kms-verification/verifier/verify.go) - Go

The main shortcoming of this idea and why it isn't practical for use by itself in a production scenario is it only addresses authentication, not authorization. I believe AWS IAM roles are about the best root of trust available, but a good authorization system is necessary. Hashicorp Vault and CyberArk bring robust implementations on the authorization side, but that is not something I would want to code custom.

This is where AWS VPC Lattice comes in. I was very excited to hear about it when I attended Re:Invent last year. I switched my schedule around to go to a talk by the Lattice team. AWS API Gateway private APIs to backends over PrivateLink accomplishes something similar from a security perspective but has a much more complex set of AWS resources. That is worth it when you are trying to achieve API governance, but sometimes you just want a simple connection with good security. The VPC lattice target group construct achieves this perfectly. VPC lattice uses IAM-format [auth policies](https://docs.aws.amazon.com/vpc-lattice/latest/ug/auth-policies.html), very similar to API Gateway IAM authentication. I was hoping that the [ARN format](https://docs.aws.amazon.com/vpc-lattice/latest/ug/auth-policies.html#auth-policies-resource-format) would be a stable identifier based on service name so they would still work if a service was deleted and recreated, but it seems to be a random ID like API Gateway. I looking forward to reading more about and hopefully playing with VPC Lattice in the future.
